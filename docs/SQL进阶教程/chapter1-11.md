# SQL 优化

## 使用高效的查询

- **参数是子查询时，使用EXISTS代替IN**

如果连接列（id）上建立了索引，那么查询Class_B时不用查实际的表，只需查索引就可以了。

如果使用EXISTS，那么只要查到一行数据满足条件就会终止查询，不用像使用IN时一样扫描全表。在这一点上NOT EXISTS也一样。

当IN的参数是子查询时，数据库首先会执行子查询，然后将结果存储在一张临时的工作表里（内联视图），然后扫描整个视图。

- **参数是子查询时，使用连接代替IN**

## 避免排序

但是，这样并不意味着在数据库内部也不能进行排序。其实正好相反，在数据库内部频繁地进行着暗中的排序。

会进行排序的代表性的运算有下面这些。

```
GROUP BY
ORDER BY
聚合函数
DISTINCT
集合运算符
窗口函数

```

**灵活使用集合运算符的ALL可选项**

**使用EXISTS代替DISTINCT**

**在极值函数中使用索引（MAX/MIN）**

使用这两个函数时都会进行排序。但是如果参数字段上建有索引，则只需要扫描索引，不需要扫描整张表。

**能写在WHERE子句里的条件不要写在HAVING子句里**

第一个是在使用GROUP BY子句聚合时会进行排序，如果事先通过WHERE子句筛选出一部分行，就能够减轻排序的负担。

第二个是在WHERE子句的条件里可以使用索引。HAVING子句是针对聚合后生成的视图进行筛选的，但是很多时候聚合后的视图都没有继承原表的索引结构。

**在GROUP BY子句和ORDER BY子句中使用索引**

一般来说，GROUP BY子句和ORDER BY子句都会进行排序，来对行进行排列和替换。

不过，通过指定带索引的列作为GROUP BY和ORDER BY的列，可以实现高速查询。特别是，在一些数据库中，如果操作对象的列上建立的是唯一索引，那么排序过程本身都会被省略掉。

## 索引命中

**在索引字段上进行运算**

使用索引时，条件表达式的左侧应该是原始字段.

**使用IS NULL 谓词**

关于索引字段不存在NULL的原因，简单来说是NULL并不是值。非值不会被包含在值的集合中

**使用否定形式**

下面这几种否定形式不能用到索引。

```
<>
!=
NOT IN
```

**使用联合索引时，列的顺序错误**

假设存在这样顺序的一个联合索引“col_1, col_2, col_3”。

联合索引中的第一列（col_1）必须写在查询条件的开头，而且索引中列的顺序不能颠倒。

**使用LIKE谓词进行后方一致或中间一致的匹配**

使用LIKE谓词时，只有前方一致的匹配才能用到索引。

## 减少中间表

频繁使用中间表会带来两个问题，一是展开数据需要耗费内存资源，二是原始表中的索引不容易使用到（特别是聚合时）。

**灵活使用HAVING子句**

HAVING子句和聚合操作是同时执行的，所以比起生成中间表后再执行的WHERE子句，效率会更高一些，而且代码看起来也更简洁。

**需要对多个字段使用IN谓词时，将它们汇总到一处**

**先进行连接再进行聚合**

1-5节提到过，连接和聚合同时使用时，先进行连接操作可以避免产生中间表。原因是，从集合运算的角度来看，连接做的是“乘法运算”。连接表双方是一对一、一对多的关系时，连接运算后数据的行数不会增加。而且，因为在很多设计中多对多的关系都可以分解成两个一对多的关系，因此这个技巧在大部分情况下都可以使用。