# 5 索引

## 5.1 索引基础

### 5.1.1 索引的类型

**B-tree索引。**

B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。

B-Tree对索引列是顺序组织存储的，所以很适合查找范围数据。

B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找。

假如有如下的数据表：

```mysql
create table People (
	last_name varchar(50) not null,
    first_name varchar(50) not null,
    dob        date not null,
    gender     enum('m', 'f') not null,
    key(last_name, first_name, dob)
);
```

那么下面的情况可以使用B-Tree索引：

- 全值匹配：和索引中的所有列进行匹配，例如前面提到的索引可用于查找姓名为Cuba Allen、出生于1960-01-01的人。
- 匹配最左前缀：可用于查找所有姓为Allen的人，即只使用索引的第一列
- 匹配列前缀：只匹配某一列的值的开头部分。例如前面提到的索引可用于查找所有以J开头的姓的人。
- 匹配范围值：可用于查找姓在Allen和Barrymore之间的人。这里也只使用了索引的第一列。
- 精确匹配某一列并范围匹配另外一列：可用于查找所有姓为Allen，并且名字是字母K开头（比如Kim、Karl等）的人。
- 只访问索引的查询：即查询只需要访问索引，而无须访问数据行。

因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的ORDER BY操作（按顺序查找）。

下面是一些关于B-Tree索引的限制：

- 如果不是按照索引的最左列开始查找，则无法使用索引。
- 不能跳过索引中的列。也就是说，前面所述的索引无法用于查找姓为Smith并且在某个特定日期出生的人。如果不指定名(first_name)，则MySQL只能使用索引的第一列。
- 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。

**哈希索引**

哈希索引(hash index)基于哈希表实现，只有精确匹配索引所有列的查询才有效[插图]。

因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引查找的速度非常快。然而，哈希索引也有它的限制：

- 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。
- 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。
- 哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。
- 哈希索引只支持等值比较查询
- 访问哈希索引的数据非常快，除非有很多哈希冲突（不同的索引列值却有相同的哈希值）。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。

InnoDB引擎有一个特殊的功能叫做“自适应哈希索引(adaptive hash index)”。当InnoDB注意到某些索引值被使用得非常频繁时，它会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，比如快速的哈希查找。

A)创建自定义的哈希索引。

```mysql
# 下面是一个实例，例如需要存储大量的URL，并需要根据URL进行搜索查找。如果使用B-Tree来存储URL，存储的内容就会很大，因为URL本身都很长。
select id from url where url="http://xxxxxxxx.com" 
# 若删除原来URL列上的索引，而新增一个被索引的url_crc列，使用CRC32做哈希，就可以使用下面的方式查询：
select id from url where url="http://xxxxxxxx.com" and url_crc=CRC32("http://xxxxxxxx.com")

# 这样做的性能会非常高，因为MySQL优化器会使用这个选择性很高而体积很小的基于url_crc列的索引来完成查找

# 这样实现的缺陷是需要维护哈希值。可以手动维护，也可以使用触发器实现。

create table pseudohash (
	id int,
    url varchar(255) not null,
    url_crc int unsigned not null default 0,
    primary key(id)
);

delimiter //

create trigger pseudohash_crc_ins before insert on pseudohash for each row begin
set new.url_crc=crc32(NEW.url);
END;
//

delimiter //

create trigger pseudohash_crc_ins before update on pseudohash for each row begin
set new.url_crc=crc32(NEW.url);
END;
//

# 如果数据表非常大，CRC32()会出现大量的哈希冲突，则可以考虑自己实现一个简单的64位哈希函数。
```

B)处理哈希冲突。当使用哈希索引进行查询的时候，必须在WHERE子句中包含常量值：

```mysql
select id from url where url="http://xxxxxxxx.com" and url_crc=CRC32("http://xxxxxxxx.com")
```

CRC32()返回的是32位的整数，当索引有93 000条记录时出现冲突的概率是1%。

**空间数据索引 R-tree**

**全文索引**

全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。

在相同的列上同时创建全文索引和基于值的B-Tree索引不会有冲突，全文索引适用于MATCH AGAINST操作，而不是普通的WHERE条件操作。

## 5.2 索引的优点

最常见的B-Tree索引，按照顺序存储数据，所以MySQL可以用来做ORDER BY和GROUP BY操作。因为数据是有序的，所以B-Tree也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。

## 5.3 高性能的索引策略

### 5.3.1 独立的列

如果查询中的列不是独立的，则MySQL就不会使用索引。“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。

### 5.3.2 前缀索引和索引选择性

有时候需要索引很长的字符列：

通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。

但这样也会降低索引的选择性。索引的选择性是指，不重复的索引值（也称为基数， cardinality）和数据表的记录总数(#T)的比值，范围从1/#T到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

为了决定前缀的合适长度，需要找到最常见的值的列表，然后和最常见的前缀列表进行比较。

首先，我们找到最常见的城市列表：

```mysql
select count(*) as cnt, city from city_demo group by city order by cnt desc limit 10
```

现在查找到最频繁出现的城市前缀，先从3个前缀字母开始：

```mysql
select count(*) as cnt, left(city, 3) as pref from city_demo group by pref order by cnt desc limit 10
```

计算合适的前缀长度的另外一个办法就是计算完整列的选择性，并使前缀的选择性接近于完整列的选择性。下面显示如何计算完整列的选择性：

```mysql
select count(distinct city) / count(*) from city_demo;
```

![image-20230809145859912](.assets/image-20230809145859912.png)

在上面的示例中，已经找到了合适的前缀长度，下面演示一下如何创建前缀索引：

```mysql
alter table city_demo add key (city(7));
```

前缀索引是一种能使索引更小、更快的有效办法，但另一方面也有其缺点：MySQL无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。

### 5.3.3 多列索引

