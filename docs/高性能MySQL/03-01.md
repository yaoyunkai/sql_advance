# 1. MySQL的架构

## 1.1 MySQL逻辑架构

## 1.2 并发控制

本章的目的是讨论MySQL在两个层面的并发控制：服务器层与存储引擎层。

**读写锁**

一个client在读取一行数据，另一个client想删除这个客户端正在读取的数据。

解决这类经典问题的方法就是并发控制，其实非常简单。在处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁(shared lock)和排他锁(exclusive lock)，也叫读锁(read lock)和写锁(write lock)。

读锁是共享的，或者说是相互不阻塞的。多个客户在同一时刻可以同时读取同一个资源，而互不干扰。写锁则是排他的，也就是说一个写锁会阻塞其他的写锁和读锁。

**锁的粒度**

一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。更理想的方式是，只对会修改的数据片进行精确的锁定。

问题是加锁也需要消耗资源。锁的各种操作，包括获得锁、检查锁是否已经解除、释放锁等，都会增加系统的开销。

所谓的锁策略，就是在锁的开销和数据的安全性之间寻求平衡，这种平衡当然也会影响到性能。

**表锁 table lock**

表锁是MySQL中最基本的锁策略，并且是开销最小的策略。

一个用户在对表进行写操作（插入、删除、更新等）前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。

只有没有写锁时，其他读取的用户才能获得读锁，读锁之间是不相互阻塞的。

写锁也比读锁有更高的优先级.

**行锁 row lock**

行级锁只在存储引擎层实现.

## 1.3 事务 Transaction

事务的四个特性：ACID

- 原子性(atomicity)
- 一致性(consistency)：数据库总是从一个一致性的状态转换到另外一个一致性的状态。
- 隔离性(isolation)：通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。
- 持久性(durability)：一旦事务提交，则其所做的修改就会永久保存到数据库中。

即使存储引擎不支持事务，也可以通过`LOCK TABLES`语句为应用提供一定程度的保护，这些选择用户都可以自主决定。

### 1.3.1 隔离级别

事务可以读取未提交的数据，这也被称为脏读(Dirty Read)



在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。

- READ UNCOMMITTED（未提交读）：事务中的修改，即使没有提交，对其他事务也都是可见的。
- READ COMMITTED（提交读）：